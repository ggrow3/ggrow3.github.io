<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeopardy!</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.4.21/vue.global.prod.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Oswald:wght@400;700&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --jeopardy-blue: #060ce9;
      --jeopardy-blue-dark: #0408a8;
      --jeopardy-gold: #d4af37;
      --jeopardy-gold-light: #ffd700;
      --daily-double-red: #cc0000;
      --cell-shadow: 0 4px 8px rgba(0,0,0,0.4);
      --gold-gradient: linear-gradient(135deg, #d4af37, #f4e19c, #d4af37);
    }

    body {
      font-family: 'Oswald', sans-serif;
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Scanline effect overlay */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        rgba(0,0,0,0.1) 0px,
        rgba(0,0,0,0.1) 1px,
        transparent 1px,
        transparent 2px
      );
      pointer-events: none;
      z-index: 1000;
    }

    #app {
      max-width: 1500px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Header */
    .header {
      text-align: center;
      margin-bottom: 30px;
      position: relative;
    }

    .logo {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 84px;
      background: var(--gold-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      filter: drop-shadow(3px 3px 0 rgba(0,0,0,0.5));
      letter-spacing: 8px;
      animation: logoGlow 2s ease-in-out infinite alternate;
    }

    @keyframes logoGlow {
      from { filter: drop-shadow(3px 3px 0 rgba(0,0,0,0.5)) drop-shadow(0 0 20px rgba(212,175,55,0.3)); }
      to { filter: drop-shadow(3px 3px 0 rgba(0,0,0,0.5)) drop-shadow(0 0 40px rgba(212,175,55,0.6)); }
    }

    .nav-buttons {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }

    .nav-btn {
      font-family: 'Oswald', sans-serif;
      font-size: 18px;
      padding: 12px 30px;
      border: 2px solid var(--jeopardy-gold);
      background: transparent;
      color: var(--jeopardy-gold);
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .nav-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: var(--gold-gradient);
      transition: left 0.3s ease;
      z-index: -1;
    }

    .nav-btn:hover {
      color: #1a1a2e;
    }

    .nav-btn:hover::before {
      left: 0;
    }

    .nav-btn.active {
      background: var(--gold-gradient);
      color: #1a1a2e;
    }

    /* Game Board */
    .game-board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 10px;
      background: #000;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 50px rgba(6,12,233,0.5), inset 0 0 30px rgba(0,0,0,0.8);
      border: 5px solid var(--jeopardy-gold);
      max-width: 1400px;
      margin: 0 auto;
    }

    .category-cell {
      background: var(--jeopardy-blue);
      padding: 22px 12px;
      text-align: center;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      font-size: 20px;
      color: white;
      text-transform: uppercase;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      border-radius: 6px;
      box-shadow: var(--cell-shadow);
      min-height: 90px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1.2;
    }

    .value-cell {
      background: linear-gradient(180deg, var(--jeopardy-blue) 0%, var(--jeopardy-blue-dark) 100%);
      padding: 35px 15px;
      text-align: center;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 52px;
      color: var(--jeopardy-gold);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      cursor: pointer;
      border-radius: 6px;
      box-shadow: var(--cell-shadow);
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .value-cell::before {
      content: '$';
    }

    .value-cell:hover:not(.revealed) {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(212,175,55,0.5);
      z-index: 10;
    }

    .value-cell.revealed {
      background: linear-gradient(180deg, #1a1a4a 0%, #0a0a2a 100%);
      color: #333;
      cursor: default;
    }

    .value-cell.revealed::before {
      content: '';
    }

    /* Question Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 500;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .question-card {
      background: var(--jeopardy-blue);
      padding: 60px 80px;
      border-radius: 12px;
      max-width: 900px;
      width: 90%;
      text-align: center;
      box-shadow: 0 0 100px rgba(6,12,233,0.8), 0 0 50px rgba(212,175,55,0.3);
      border: 6px solid var(--jeopardy-gold);
      animation: slideIn 0.4s ease;
    }

    @keyframes slideIn {
      from { transform: scale(0.8) translateY(-50px); opacity: 0; }
      to { transform: scale(1) translateY(0); opacity: 1; }
    }

    .question-value {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 72px;
      color: var(--jeopardy-gold);
      text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
      margin-bottom: 30px;
    }

    .question-text {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 36px;
      color: white;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      line-height: 1.4;
      margin-bottom: 40px;
      text-transform: uppercase;
    }

    .answer-text {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 28px;
      color: var(--jeopardy-gold-light);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      margin-bottom: 30px;
      padding: 20px;
      border: 2px solid var(--jeopardy-gold);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
    }

    .modal-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .modal-btn {
      font-family: 'Oswald', sans-serif;
      font-size: 20px;
      padding: 15px 40px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.3s ease;
    }

    .modal-btn.reveal {
      background: var(--gold-gradient);
      color: #1a1a2e;
    }

    .modal-btn.close {
      background: #333;
      color: white;
      border: 2px solid #666;
    }

    .modal-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }

    /* Daily Double Animation */
    .daily-double-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, var(--daily-double-red) 0%, #330000 70%, #000 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 600;
      animation: ddFlash 0.5s ease;
    }

    @keyframes ddFlash {
      0% { opacity: 0; }
      50% { opacity: 1; background: white; }
      100% { opacity: 1; }
    }

    .daily-double-content {
      text-align: center;
      animation: ddPulse 0.8s ease infinite alternate;
    }

    @keyframes ddPulse {
      from { transform: scale(1); }
      to { transform: scale(1.05); }
    }

    .daily-double-text {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 120px;
      color: var(--jeopardy-gold);
      text-shadow: 4px 4px 0 #000, 8px 8px 20px rgba(0,0,0,0.8);
      letter-spacing: 10px;
      animation: ddGlow 0.3s ease infinite alternate;
    }

    @keyframes ddGlow {
      from { text-shadow: 4px 4px 0 #000, 0 0 30px var(--jeopardy-gold); }
      to { text-shadow: 4px 4px 0 #000, 0 0 60px var(--jeopardy-gold), 0 0 100px var(--jeopardy-gold-light); }
    }

    .daily-double-subtitle {
      font-family: 'Oswald', sans-serif;
      font-size: 36px;
      color: white;
      margin-top: 20px;
      text-transform: uppercase;
      letter-spacing: 5px;
    }

    .dd-stars {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .dd-star {
      position: absolute;
      font-size: 40px;
      color: var(--jeopardy-gold);
      animation: starFloat 2s ease-in-out infinite;
    }

    @keyframes starFloat {
      0%, 100% { transform: translateY(0) rotate(0deg); opacity: 1; }
      50% { transform: translateY(-20px) rotate(180deg); opacity: 0.5; }
    }

    /* Admin Panel */
    .admin-panel {
      background: linear-gradient(180deg, #1e1e3f 0%, #12122a 100%);
      padding: 30px;
      border-radius: 12px;
      border: 2px solid var(--jeopardy-gold);
      box-shadow: 0 0 30px rgba(6,12,233,0.3);
    }

    .admin-section {
      margin-bottom: 40px;
    }

    .admin-title {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 36px;
      color: var(--jeopardy-gold);
      margin-bottom: 20px;
      border-bottom: 2px solid var(--jeopardy-gold);
      padding-bottom: 10px;
    }

    .admin-subtitle {
      font-family: 'Oswald', sans-serif;
      font-size: 24px;
      color: white;
      margin-bottom: 15px;
      margin-top: 25px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 16px;
      color: #aaa;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .form-input, .form-textarea, .form-select {
      width: 100%;
      padding: 12px 15px;
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 16px;
      background: #0a0a1a;
      border: 2px solid #333;
      border-radius: 6px;
      color: white;
      transition: border-color 0.3s ease;
    }

    .form-input:focus, .form-textarea:focus, .form-select:focus {
      outline: none;
      border-color: var(--jeopardy-gold);
    }

    .form-textarea {
      min-height: 100px;
      resize: vertical;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }

    .checkbox-group input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: var(--jeopardy-gold);
    }

    .checkbox-group label {
      font-family: 'Roboto Condensed', sans-serif;
      color: #ccc;
      font-size: 16px;
    }

    .admin-btn {
      font-family: 'Oswald', sans-serif;
      font-size: 16px;
      padding: 12px 25px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
      margin-right: 10px;
      margin-bottom: 10px;
    }

    .admin-btn.primary {
      background: var(--gold-gradient);
      color: #1a1a2e;
    }

    .admin-btn.secondary {
      background: #333;
      color: white;
      border: 2px solid #555;
    }

    .admin-btn.danger {
      background: #660000;
      color: white;
      border: 2px solid #990000;
    }

    .admin-btn.ai {
      background: linear-gradient(135deg, #10a37f, #1a7f5a);
      color: white;
    }

    .admin-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .admin-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Category Editor Grid */
    .category-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
    }

    .category-card {
      background: #0a0a1a;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 20px;
      transition: border-color 0.3s ease;
    }

    .category-card:hover {
      border-color: var(--jeopardy-gold);
    }

    .category-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .category-card-title {
      font-family: 'Oswald', sans-serif;
      font-size: 18px;
      color: var(--jeopardy-gold);
    }

    .question-list {
      list-style: none;
    }

    .question-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: #1a1a2e;
      border-radius: 4px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .question-item:hover {
      background: #2a2a4e;
    }

    .question-item-value {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 20px;
      color: var(--jeopardy-gold);
    }

    .question-item-status {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .question-item-status.has-content {
      background: #1a5a1a;
      color: #4ade80;
    }

    .question-item-status.empty {
      background: #5a1a1a;
      color: #f87171;
    }

    .question-item-status.daily-double {
      background: var(--daily-double-red);
      color: white;
    }

    /* AI Generation Section */
    .ai-section {
      background: linear-gradient(135deg, rgba(16,163,127,0.1), rgba(16,163,127,0.05));
      border: 2px solid #10a37f;
      border-radius: 8px;
      padding: 25px;
      margin-bottom: 30px;
    }

    .ai-section-title {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 28px;
      color: #10a37f;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .ai-icon {
      font-size: 24px;
    }

    .ai-description {
      font-family: 'Roboto Condensed', sans-serif;
      color: #aaa;
      margin-bottom: 20px;
      line-height: 1.5;
    }

    .theme-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }

    .theme-chip {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 14px;
      padding: 8px 16px;
      background: #1a1a2e;
      border: 1px solid #333;
      border-radius: 20px;
      color: #ccc;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .theme-chip:hover {
      background: #10a37f;
      border-color: #10a37f;
      color: white;
    }

    /* Loading Spinner */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Scoreboard */
    .scoreboard {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    .player-score {
      background: linear-gradient(180deg, #1e1e3f 0%, #12122a 100%);
      padding: 20px 40px;
      border-radius: 8px;
      border: 2px solid var(--jeopardy-gold);
      text-align: center;
      min-width: 200px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .player-score:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .player-score.active {
      border-color: #4ade80;
      box-shadow: 0 0 20px rgba(74,222,128,0.3);
    }

    .player-name {
      font-family: 'Oswald', sans-serif;
      font-size: 20px;
      color: white;
      margin-bottom: 10px;
    }

    .player-amount {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 36px;
      color: var(--jeopardy-gold);
    }

    .player-amount.negative {
      color: #f87171;
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 1000;
    }

    .toast {
      background: #1e1e3f;
      border: 2px solid var(--jeopardy-gold);
      border-radius: 8px;
      padding: 15px 25px;
      margin-top: 10px;
      color: white;
      font-family: 'Roboto Condensed', sans-serif;
      animation: toastSlide 0.3s ease;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }

    .toast.success {
      border-color: #4ade80;
    }

    .toast.error {
      border-color: #f87171;
    }

    @keyframes toastSlide {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .category-cell {
        font-size: 18px;
        padding: 20px 10px;
        min-height: 80px;
      }

      .value-cell {
        font-size: 42px;
        padding: 30px 10px;
        min-height: 100px;
      }
    }

    @media (max-width: 768px) {
      .logo {
        font-size: 48px;
      }

      .game-board {
        gap: 4px;
        padding: 10px;
      }

      .category-cell {
        font-size: 12px;
        padding: 10px 5px;
        min-height: 60px;
      }

      .value-cell {
        font-size: 24px;
        padding: 15px 5px;
        min-height: 70px;
      }

      .question-card {
        padding: 30px 20px;
      }

      .question-value {
        font-size: 48px;
      }

      .question-text {
        font-size: 24px;
      }

      .daily-double-text {
        font-size: 60px;
      }
    }

    /* Edit Modal */
    .edit-modal {
      background: #1e1e3f;
      padding: 40px;
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      border: 3px solid var(--jeopardy-gold);
      max-height: 90vh;
      overflow-y: auto;
    }

    .edit-modal-title {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 32px;
      color: var(--jeopardy-gold);
      margin-bottom: 25px;
    }

    /* API Key Input */
    .api-key-section {
      background: #0a0a1a;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .api-key-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .api-key-status {
      font-size: 14px;
      padding: 4px 12px;
      border-radius: 4px;
    }

    .api-key-status.connected {
      background: #1a5a1a;
      color: #4ade80;
    }

    .api-key-status.not-connected {
      background: #5a1a1a;
      color: #f87171;
    }

    /* Player Management */
    .player-management {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    .player-input-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .player-input-group input {
      width: 150px;
    }

    .small-btn {
      padding: 8px 15px;
      font-size: 14px;
    }

    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .mode-btn {
      flex: 1;
      font-family: 'Oswald', sans-serif;
      font-size: 16px;
      padding: 12px 20px;
      background: #0a0a1a;
      border: 2px solid #333;
      border-radius: 6px;
      color: #888;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .mode-btn:hover {
      border-color: #555;
      color: #ccc;
    }

    .mode-btn.active {
      border-color: var(--jeopardy-gold);
      color: var(--jeopardy-gold);
      background: rgba(212, 175, 55, 0.1);
    }

    /* Column Themes */
    .column-themes {
      margin-top: 15px;
    }

    .column-theme-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 10px;
    }

    .column-theme-item {
      background: #0a0a1a;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 12px;
    }

    .column-label {
      display: block;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 18px;
      color: var(--jeopardy-gold);
      margin-bottom: 8px;
    }

    .column-theme-item .form-input {
      font-size: 14px;
      padding: 8px 10px;
    }

    /* Form hints */
    .form-hint {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
      font-style: italic;
    }

    /* Selected themes display */
    .selected-themes {
      margin-top: 15px;
      padding: 15px;
      background: rgba(212, 175, 55, 0.05);
      border: 1px solid rgba(212, 175, 55, 0.2);
      border-radius: 6px;
    }

    .selected-theme-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 14px;
      padding: 6px 12px;
      background: var(--jeopardy-blue);
      border: 1px solid var(--jeopardy-gold);
      border-radius: 20px;
      color: white;
      margin-right: 8px;
      margin-bottom: 8px;
    }

    .remove-theme {
      cursor: pointer;
      color: #f87171;
      font-weight: bold;
      font-size: 16px;
      line-height: 1;
    }

    .remove-theme:hover {
      color: #fca5a5;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: linear-gradient(180deg, #1e1e3f 0%, #12122a 100%);
      border: 2px solid var(--jeopardy-gold);
      border-radius: 8px;
      padding: 8px 0;
      min-width: 220px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 20px rgba(212,175,55,0.2);
      z-index: 1000;
      animation: contextMenuIn 0.15s ease;
    }

    @keyframes contextMenuIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }

    .context-menu-header {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 18px;
      color: var(--jeopardy-gold);
      padding: 8px 16px 12px;
      border-bottom: 1px solid #333;
      margin-bottom: 8px;
    }

    .context-menu-item {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 15px;
      color: #ccc;
      padding: 10px 16px;
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .context-menu-item:hover {
      background: rgba(212,175,55,0.15);
      color: white;
    }

    .context-menu-item.danger {
      color: #f87171;
    }

    .context-menu-item.danger:hover {
      background: rgba(248,113,113,0.15);
      color: #fca5a5;
    }

    .context-menu-divider {
      height: 1px;
      background: #333;
      margin: 8px 0;
    }

    .context-menu-section-label {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 11px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 6px 16px 4px;
    }

    .context-menu-item.award {
      color: #4ade80;
    }

    .context-menu-item.award:hover {
      background: rgba(74,222,128,0.15);
      color: #86efac;
    }

    .context-menu-item.deduct {
      color: #f87171;
    }

    .context-menu-item.deduct:hover {
      background: rgba(248,113,113,0.15);
      color: #fca5a5;
    }

    /* Fullscreen Mode */
    .fullscreen-mode {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
      z-index: 100;
      padding: 20px;
      overflow: auto;
      display: flex;
      flex-direction: column;
    }

    .fullscreen-mode .header {
      display: none;
    }

    .fullscreen-mode .scoreboard {
      margin: 10px 0 20px;
    }

    .fullscreen-mode .game-board {
      flex: 1;
      max-width: 100%;
      max-height: calc(100vh - 250px);
    }

    .fullscreen-mode .category-cell {
      font-size: 24px;
      min-height: 80px;
    }

    .fullscreen-mode .value-cell {
      font-size: 64px;
      min-height: 90px;
    }

    .fullscreen-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .fullscreen-title {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 48px;
      background: var(--gold-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .fullscreen-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* Final Jeopardy */
    .final-jeopardy-section {
      margin-top: 30px;
      display: flex;
      justify-content: center;
    }

    .final-jeopardy-card {
      background: linear-gradient(180deg, #4a0080 0%, #2d004d 100%);
      border: 4px solid var(--jeopardy-gold);
      border-radius: 12px;
      padding: 30px 60px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 0 30px rgba(74,0,128,0.5), 0 0 15px rgba(212,175,55,0.3);
      min-width: 400px;
    }

    .final-jeopardy-card:hover:not(.revealed) {
      transform: scale(1.02);
      box-shadow: 0 0 50px rgba(74,0,128,0.7), 0 0 30px rgba(212,175,55,0.5);
    }

    .final-jeopardy-card.revealed {
      background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2a 100%);
      cursor: default;
    }

    .final-jeopardy-card.locked {
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
      border-color: #444;
      cursor: not-allowed;
      box-shadow: none;
    }

    .final-jeopardy-card.locked:hover {
      transform: none;
      box-shadow: none;
    }

    .final-jeopardy-card.locked .final-jeopardy-label {
      color: #555;
    }

    .final-jeopardy-locked-msg {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 18px;
      color: #666;
      margin-bottom: 8px;
    }

    .final-jeopardy-progress {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 24px;
      color: #444;
    }

    /* Wrong Answer Animation */
    .wrong-answer-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, #660000 0%, #330000 50%, #000 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 700;
      animation: wrongFlash 0.3s ease;
      cursor: pointer;
    }

    @keyframes wrongFlash {
      0% { opacity: 0; }
      30% { opacity: 1; background: #ff0000; }
      100% { opacity: 1; }
    }

    .wrong-answer-content {
      text-align: center;
      animation: wrongShake 0.5s ease;
      position: relative;
      z-index: 2;
    }

    @keyframes wrongShake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
      20%, 40%, 60%, 80% { transform: translateX(10px); }
    }

    .wrong-x {
      font-size: 180px;
      color: #ff0000;
      text-shadow: 0 0 50px #ff0000, 0 0 100px #ff0000;
      animation: wrongPulse 0.3s ease-in-out infinite alternate;
      line-height: 1;
    }

    @keyframes wrongPulse {
      from { transform: scale(1); opacity: 0.8; }
      to { transform: scale(1.1); opacity: 1; }
    }

    .wrong-text {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 96px;
      color: white;
      text-shadow: 4px 4px 0 #000, 0 0 30px rgba(255,0,0,0.8);
      letter-spacing: 10px;
      margin-top: -20px;
    }

    .wrong-amount {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 72px;
      color: #ff4444;
      text-shadow: 0 0 20px rgba(255,0,0,0.5);
      margin-top: 10px;
    }

    .wrong-player {
      font-family: 'Oswald', sans-serif;
      font-size: 32px;
      color: #888;
      margin-top: 20px;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .wrong-sparks {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .spark {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #ff4444;
      border-radius: 50%;
      box-shadow: 0 0 10px #ff0000, 0 0 20px #ff4444;
      animation: sparkFly 1s ease-out forwards;
    }

    @keyframes sparkFly {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
      }
    }

    /* Correct Answer Animation */
    .correct-answer-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, #1a4d1a 0%, #0d260d 50%, #000 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 700;
      animation: correctFlash 0.3s ease;
      cursor: pointer;
      overflow: hidden;
    }

    @keyframes correctFlash {
      0% { opacity: 0; }
      30% { opacity: 1; background: #00ff00; }
      100% { opacity: 1; }
    }

    .correct-answer-content {
      text-align: center;
      position: relative;
      z-index: 2;
      animation: correctBounce 0.6s ease;
    }

    @keyframes correctBounce {
      0% { transform: scale(0); }
      50% { transform: scale(1.2); }
      70% { transform: scale(0.9); }
      100% { transform: scale(1); }
    }

    .correct-check {
      font-size: 180px;
      color: #4ade80;
      text-shadow: 0 0 50px #4ade80, 0 0 100px #22c55e;
      animation: correctPulse 0.4s ease-in-out infinite alternate;
      line-height: 1;
    }

    @keyframes correctPulse {
      from { transform: scale(1); filter: drop-shadow(0 0 30px #4ade80); }
      to { transform: scale(1.1); filter: drop-shadow(0 0 60px #4ade80); }
    }

    .correct-text {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 96px;
      color: white;
      text-shadow: 4px 4px 0 #000, 0 0 30px rgba(74,222,128,0.8);
      letter-spacing: 10px;
      margin-top: -20px;
    }

    .correct-amount {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 72px;
      color: var(--jeopardy-gold);
      text-shadow: 0 0 20px rgba(212,175,55,0.8);
      margin-top: 10px;
      animation: amountPop 0.5s ease 0.2s both;
    }

    @keyframes amountPop {
      0% { transform: scale(0); opacity: 0; }
      70% { transform: scale(1.2); }
      100% { transform: scale(1); opacity: 1; }
    }

    .correct-player {
      font-family: 'Oswald', sans-serif;
      font-size: 32px;
      color: #ccc;
      margin-top: 20px;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .correct-stars {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .correct-star {
      position: absolute;
      color: var(--jeopardy-gold);
      text-shadow: 0 0 10px var(--jeopardy-gold);
      animation: starBurst 1.5s ease-out forwards;
      opacity: 0;
    }

    @keyframes starBurst {
      0% {
        transform: translate(0, 0) scale(0) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(1) rotate(360deg);
        opacity: 0;
      }
    }

    .correct-rays {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100%;
      height: 100%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    .ray {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 50vh;
      background: linear-gradient(to top, transparent, rgba(74,222,128,0.4), transparent);
      transform-origin: bottom center;
      animation: rayRotate 3s linear infinite;
    }

    @keyframes rayRotate {
      from { opacity: 0.3; }
      50% { opacity: 0.6; }
      to { opacity: 0.3; }
    }

    .final-jeopardy-label {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 42px;
      color: var(--jeopardy-gold);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      letter-spacing: 3px;
      margin-bottom: 10px;
    }

    .final-jeopardy-category {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 24px;
      color: white;
      text-transform: uppercase;
    }

    .final-jeopardy-used {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 20px;
      color: #666;
    }

    .fullscreen-mode .final-jeopardy-section {
      margin-top: 20px;
    }

    .fullscreen-mode .final-jeopardy-card {
      padding: 20px 50px;
    }

    .fullscreen-mode .final-jeopardy-label {
      font-size: 36px;
    }

    .final-jeopardy-admin-card {
      background: linear-gradient(180deg, rgba(147,51,234,0.1) 0%, rgba(107,33,168,0.05) 100%);
      border: 2px solid #9333ea;
      border-radius: 8px;
      padding: 25px;
    }

    /* Game Over Celebration */
    .game-over-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 700;
      animation: fadeIn 0.5s ease;
    }

    .game-over-content {
      text-align: center;
      position: relative;
      z-index: 2;
    }

    .game-over-title {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 80px;
      background: var(--gold-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: titlePulse 1s ease-in-out infinite alternate;
      margin-bottom: 20px;
    }

    @keyframes titlePulse {
      from { transform: scale(1); filter: drop-shadow(0 0 20px rgba(212,175,55,0.5)); }
      to { transform: scale(1.05); filter: drop-shadow(0 0 40px rgba(212,175,55,0.8)); }
    }

    .winner-announcement {
      font-family: 'Oswald', sans-serif;
      font-size: 36px;
      color: white;
      margin-bottom: 30px;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .winner-name {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 72px;
      color: var(--jeopardy-gold);
      text-shadow: 0 0 30px rgba(212,175,55,0.8);
      animation: winnerGlow 0.5s ease-in-out infinite alternate;
      margin-bottom: 10px;
    }

    @keyframes winnerGlow {
      from { text-shadow: 0 0 30px rgba(212,175,55,0.5), 0 0 60px rgba(212,175,55,0.3); }
      to { text-shadow: 0 0 50px rgba(212,175,55,0.8), 0 0 100px rgba(212,175,55,0.5); }
    }

    .winner-score {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 96px;
      color: #4ade80;
      text-shadow: 0 0 30px rgba(74,222,128,0.5);
      margin-bottom: 40px;
    }

    .winner-score.negative {
      color: #f87171;
      text-shadow: 0 0 30px rgba(248,113,113,0.5);
    }

    .final-scores {
      display: flex;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
      margin-bottom: 40px;
    }

    .final-score-card {
      background: linear-gradient(180deg, #1e1e3f 0%, #12122a 100%);
      padding: 20px 30px;
      border-radius: 10px;
      border: 2px solid #444;
      min-width: 150px;
      transition: all 0.3s ease;
    }

    .final-score-card.winner {
      border-color: var(--jeopardy-gold);
      box-shadow: 0 0 30px rgba(212,175,55,0.4);
      transform: scale(1.1);
    }

    .final-score-card.second {
      border-color: #c0c0c0;
    }

    .final-score-card.third {
      border-color: #cd7f32;
    }

    .final-rank {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 24px;
      color: #888;
      margin-bottom: 5px;
    }

    .final-score-card.winner .final-rank {
      color: var(--jeopardy-gold);
    }

    .final-player-name {
      font-family: 'Oswald', sans-serif;
      font-size: 20px;
      color: white;
      margin-bottom: 10px;
    }

    .final-player-score {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 36px;
      color: var(--jeopardy-gold);
    }

    .final-player-score.negative {
      color: #f87171;
    }

    /* Confetti */
    .confetti-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      top: -10px;
      animation: confettiFall linear forwards;
    }

    .confetti.square {
      border-radius: 0;
    }

    .confetti.circle {
      border-radius: 50%;
    }

    .confetti.triangle {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 12px solid currentColor;
      background: transparent !important;
    }

    @keyframes confettiFall {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0.7;
      }
    }

    /* Spotlight effect */
    .spotlight {
      position: absolute;
      width: 300px;
      height: 300px;
      background: radial-gradient(ellipse at center, rgba(212,175,55,0.3) 0%, transparent 70%);
      border-radius: 50%;
      animation: spotlightMove 3s ease-in-out infinite;
    }

    .spotlight:nth-child(1) {
      top: 10%;
      left: 20%;
      animation-delay: 0s;
    }

    .spotlight:nth-child(2) {
      top: 30%;
      right: 15%;
      animation-delay: 1s;
    }

    .spotlight:nth-child(3) {
      bottom: 20%;
      left: 30%;
      animation-delay: 2s;
    }

    @keyframes spotlightMove {
      0%, 100% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.3); opacity: 0.8; }
    }

    /* Trophy icon */
    .trophy {
      font-size: 120px;
      margin-bottom: 20px;
      animation: trophyBounce 0.6s ease-in-out infinite;
    }

    @keyframes trophyBounce {
      0%, 100% { transform: translateY(0) rotate(-5deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }

    .play-again-btn {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 28px;
      padding: 20px 60px;
      background: var(--gold-gradient);
      border: none;
      border-radius: 10px;
      color: #1a1a2e;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 3px;
      transition: all 0.3s ease;
      margin-top: 20px;
    }

    .play-again-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 40px rgba(212,175,55,0.5);
    }

    .close-celebration-btn {
      font-family: 'Oswald', sans-serif;
      font-size: 16px;
      padding: 12px 30px;
      background: transparent;
      border: 2px solid #666;
      border-radius: 6px;
      color: #888;
      cursor: pointer;
      margin-left: 15px;
      transition: all 0.3s ease;
    }

    .close-celebration-btn:hover {
      border-color: #888;
      color: white;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Header -->
    <header class="header">
      <h1 class="logo">JEOPARDY!</h1>
      <nav class="nav-buttons">
        <button class="nav-btn" :class="{ active: currentView === 'game' }" @click="currentView = 'game'">
          Game Board
        </button>
        <button class="nav-btn" :class="{ active: currentView === 'admin' }" @click="currentView = 'admin'">
          Admin Panel
        </button>
      </nav>
    </header>

    <!-- Game View -->
    <div v-if="currentView === 'game'" :class="{ 'fullscreen-mode': isFullscreen }">
      <!-- Fullscreen Header (only shows in fullscreen) -->
      <div v-if="isFullscreen" class="fullscreen-header">
        <div class="fullscreen-title">JEOPARDY!</div>
        <div class="fullscreen-controls">
          <span style="color: #888; font-family: 'Roboto Condensed', sans-serif;">
            {{ revealedCells.size }} / {{ totalQuestions }} answered
          </span>
          <button class="admin-btn primary" @click="finishGame" :disabled="revealedCells.size === 0">
            üèÜ End Game
          </button>
          <button class="admin-btn secondary" @click="toggleFullscreen">
            ‚õ∂ Exit
          </button>
        </div>
      </div>

      <!-- Regular Fullscreen Toggle (only shows when not fullscreen) -->
      <div v-if="!isFullscreen" style="text-align: right; margin-bottom: 10px;">
        <button class="admin-btn secondary" @click="toggleFullscreen">
          ‚õ∂ Fullscreen Mode
        </button>
      </div>

      <!-- Scoreboard -->
      <div class="scoreboard">
        <div 
          v-for="(player, index) in players" 
          :key="index"
          class="player-score"
          :class="{ active: activePlayer === index }"
          @click="activePlayer = index"
        >
          <div class="player-name">{{ player.name }}</div>
          <div class="player-amount" :class="{ negative: player.score < 0 }">
            {{ player.score < 0 ? '-' : '' }}${{ Math.abs(player.score).toLocaleString() }}
          </div>
        </div>
      </div>

      <!-- Game Board -->
      <div class="game-board">
        <!-- Categories -->
        <div v-for="(category, catIndex) in categories" :key="'cat-' + catIndex" class="category-cell">
          {{ category.name }}
        </div>

        <!-- Questions Grid -->
        <template v-for="(value, valueIndex) in pointValues" :key="'row-' + valueIndex">
          <div 
            v-for="(category, catIndex) in categories" 
            :key="'cell-' + catIndex + '-' + valueIndex"
            class="value-cell"
            :class="{ revealed: isRevealed(catIndex, valueIndex) }"
            @click="selectQuestion(catIndex, valueIndex)"
            @contextmenu.prevent="openContextMenu($event, catIndex, valueIndex)"
          >
            <template v-if="!isRevealed(catIndex, valueIndex)">
              {{ value }}
            </template>
          </div>
        </template>
      </div>

      <!-- Final Jeopardy (only shows when all questions answered) -->
      <div v-if="isGameComplete" class="final-jeopardy-section">
        <div 
          class="final-jeopardy-card"
          :class="{ revealed: finalJeopardy.revealed }"
          @click="showFinalJeopardy"
          @contextmenu.prevent="openFinalJeopardyContext($event)"
        >
          <div class="final-jeopardy-label">FINAL JEOPARDY!</div>
          <div v-if="!finalJeopardy.revealed" class="final-jeopardy-category">
            {{ finalJeopardy.category || 'Click to reveal' }}
          </div>
          <div v-else class="final-jeopardy-used">‚úì Completed</div>
        </div>
      </div>

      <!-- Final Jeopardy Locked Message (shows before all questions answered) -->
      <div v-else class="final-jeopardy-section">
        <div class="final-jeopardy-card locked">
          <div class="final-jeopardy-label" style="opacity: 0.5;">FINAL JEOPARDY</div>
          <div class="final-jeopardy-locked-msg">
            üîí Answer all {{ totalQuestions }} questions to unlock
          </div>
          <div class="final-jeopardy-progress">
            {{ revealedCells.size }} / {{ totalQuestions }} complete
          </div>
        </div>
      </div>

      <!-- Final Jeopardy Context Menu -->
      <div 
        v-if="finalJeopardyContext.show" 
        class="context-menu"
        :style="{ top: finalJeopardyContext.y + 'px', left: finalJeopardyContext.x + 'px' }"
        @click.stop
      >
        <div class="context-menu-header">
          Final Jeopardy
        </div>
        <div class="context-menu-item" @click="editFinalJeopardy">
          ‚úèÔ∏è Edit Final Jeopardy
        </div>
        <div class="context-menu-item" @click="toggleFinalJeopardyRevealed">
          {{ finalJeopardy.revealed ? 'üëÅÔ∏è Mark Unrevealed' : 'üëÅÔ∏è‚Äçüó®Ô∏è Mark Revealed' }}
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-section-label">Award Wagers:</div>
        <div 
          v-for="(player, index) in players" 
          :key="'fj-award-' + index"
          class="context-menu-item award"
          @click="awardFinalJeopardy(index, true)"
        >
          ‚úì {{ player.name }} (Correct)
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-section-label">Deduct Wagers:</div>
        <div 
          v-for="(player, index) in players" 
          :key="'fj-deduct-' + index"
          class="context-menu-item deduct"
          @click="awardFinalJeopardy(index, false)"
        >
          ‚úó {{ player.name }} (Incorrect)
        </div>
      </div>

      <!-- Context Menu -->
      <div 
        v-if="contextMenu.show" 
        class="context-menu"
        :style="{ top: contextMenu.y + 'px', left: contextMenu.x + 'px' }"
        @click.stop
      >
        <div class="context-menu-header">
          ${{ pointValues[contextMenu.valueIndex] }} - {{ categories[contextMenu.catIndex]?.name }}
        </div>
        
        <!-- Award Points Section -->
        <div class="context-menu-section-label">Award Points To:</div>
        <div 
          v-for="(player, index) in players" 
          :key="'award-' + index"
          class="context-menu-item award"
          @click="awardPointsFromContext(index, true)"
        >
          ‚úì {{ player.name }} (+${{ pointValues[contextMenu.valueIndex] }})
        </div>
        
        <div class="context-menu-divider"></div>
        
        <!-- Deduct Points Section -->
        <div class="context-menu-section-label">Deduct Points From:</div>
        <div 
          v-for="(player, index) in players" 
          :key="'deduct-' + index"
          class="context-menu-item deduct"
          @click="awardPointsFromContext(index, false)"
        >
          ‚úó {{ player.name }} (-${{ pointValues[contextMenu.valueIndex] }})
        </div>
        
        <div class="context-menu-divider"></div>
        
        <!-- Other Options -->
        <div class="context-menu-item" @click="editFromContextMenu">
          ‚úèÔ∏è Edit Question
        </div>
        <div class="context-menu-item" @click="toggleDailyDoubleFromContext">
          ‚≠ê {{ isDailyDouble(contextMenu.catIndex, contextMenu.valueIndex) ? 'Remove Daily Double' : 'Set Daily Double' }}
        </div>
        <div class="context-menu-item" @click="toggleRevealedFromContext">
          {{ isRevealed(contextMenu.catIndex, contextMenu.valueIndex) ? 'üëÅÔ∏è Mark Unrevealed' : 'üëÅÔ∏è‚Äçüó®Ô∏è Mark Revealed' }}
        </div>
        <div class="context-menu-item" @click="previewQuestion">
          üîç Preview
        </div>
        <div class="context-menu-item danger" @click="clearQuestion">
          üóëÔ∏è Clear Question
        </div>
      </div>

      <!-- Score Adjustment (hide in fullscreen) -->
      <div v-if="!isFullscreen" style="text-align: center; margin-top: 20px;">
        <button class="admin-btn secondary small-btn" @click="adjustScore(-currentQuestionValue)" :disabled="activePlayer === null">
          -${{ currentQuestionValue || pointValues[0] }}
        </button>
        <button class="admin-btn primary small-btn" @click="adjustScore(currentQuestionValue)" :disabled="activePlayer === null">
          +${{ currentQuestionValue || pointValues[0] }}
        </button>
        <select v-model="currentQuestionValue" class="form-select" style="width: auto; display: inline-block; margin-left: 15px;">
          <option v-for="v in pointValues" :key="v" :value="v">${{ v }}</option>
        </select>
      </div>

      <!-- Game Progress (hide in fullscreen) -->
      <div v-if="!isFullscreen" style="text-align: center; margin-top: 25px;">
        <div style="color: #888; font-family: 'Roboto Condensed', sans-serif; margin-bottom: 10px;">
          Questions Answered: {{ revealedCells.size }} / {{ totalQuestions }}
        </div>
        <div style="background: #1a1a2e; height: 8px; border-radius: 4px; max-width: 400px; margin: 0 auto 15px; overflow: hidden;">
          <div 
            :style="{ width: progressPercent + '%', background: 'var(--gold-gradient)', height: '100%', transition: 'width 0.3s ease' }"
          ></div>
        </div>
        <button 
          class="admin-btn primary" 
          @click="finishGame"
          :disabled="revealedCells.size === 0"
        >
          üèÜ Finish Game
        </button>
        <span v-if="isGameComplete" style="color: #4ade80; margin-left: 15px; font-family: 'Roboto Condensed', sans-serif;">
          ‚úì All questions answered!
        </span>
      </div>
    </div>

    <!-- Admin View -->
    <div v-if="currentView === 'admin'" class="admin-panel">
      <!-- AI Generation Section -->
      <div class="ai-section">
        <h2 class="ai-section-title">
          <span class="ai-icon">ü§ñ</span>
          AI Board Generator
        </h2>
        <p class="ai-description">
          Generate a complete Jeopardy board using AI. You can use a single theme, multiple themes (comma-separated), 
          or specify individual themes for each column.
        </p>

        <div class="api-key-section">
          <div class="api-key-header">
            <span class="form-label" style="margin: 0;">Anthropic API Key</span>
            <span class="api-key-status" :class="apiKey ? 'connected' : 'not-connected'">
              {{ apiKey ? '‚úì Key Set' : '‚úó Not Set' }}
            </span>
          </div>
          <input 
            type="password" 
            class="form-input" 
            v-model="apiKey" 
            placeholder="sk-ant-..."
            @change="saveApiKey"
          >
          <p class="form-hint" style="margin-top: 8px;">Get your API key from console.anthropic.com</p>
        </div>

        <!-- Generation Mode Toggle -->
        <div class="form-group">
          <label class="form-label">Generation Mode</label>
          <div class="mode-toggle">
            <button 
              class="mode-btn" 
              :class="{ active: generationMode === 'themes' }"
              @click="generationMode = 'themes'"
            >
              üéØ By Theme(s)
            </button>
            <button 
              class="mode-btn" 
              :class="{ active: generationMode === 'columns' }"
              @click="generationMode = 'columns'"
            >
              üìä By Column
            </button>
          </div>
        </div>

        <!-- Theme-based Generation -->
        <div v-if="generationMode === 'themes'" class="form-group">
          <label class="form-label">Board Theme(s)</label>
          <p class="form-hint">Enter one theme for a focused board, or multiple themes (comma-separated) for variety</p>
          <input 
            type="text" 
            class="form-input" 
            v-model="aiTheme" 
            placeholder="e.g., 80s Pop Culture, Science, World History"
          >
          <div class="theme-suggestions">
            <span class="theme-chip" @click="addTheme('80s Pop Culture')">80s Pop Culture</span>
            <span class="theme-chip" @click="addTheme('Science & Nature')">Science & Nature</span>
            <span class="theme-chip" @click="addTheme('World Geography')">World Geography</span>
            <span class="theme-chip" @click="addTheme('Movies & TV Shows')">Movies & TV</span>
            <span class="theme-chip" @click="addTheme('Sports History')">Sports History</span>
            <span class="theme-chip" @click="addTheme('Food & Drink')">Food & Drink</span>
            <span class="theme-chip" @click="addTheme('Literature & Books')">Literature</span>
            <span class="theme-chip" @click="addTheme('Technology')">Technology</span>
            <span class="theme-chip" @click="addTheme('Music')">Music</span>
            <span class="theme-chip" @click="addTheme('Art & Artists')">Art & Artists</span>
            <span class="theme-chip" @click="addTheme('Ancient History')">Ancient History</span>
            <span class="theme-chip" @click="addTheme('Space & Astronomy')">Space & Astronomy</span>
          </div>
          <div v-if="parsedThemes.length > 1" class="selected-themes">
            <span class="form-label" style="margin-bottom: 8px; display: block;">Selected Themes ({{ parsedThemes.length }}):</span>
            <span v-for="(theme, i) in parsedThemes" :key="i" class="selected-theme-chip">
              {{ theme }}
              <span class="remove-theme" @click="removeTheme(i)">√ó</span>
            </span>
          </div>
        </div>

        <!-- Column-based Generation -->
        <div v-if="generationMode === 'columns'" class="column-themes">
          <label class="form-label">Theme for Each Column</label>
          <p class="form-hint">Specify a unique theme for each category column</p>
          <div class="column-theme-grid">
            <div v-for="(theme, index) in columnThemes" :key="index" class="column-theme-item">
              <label class="column-label">Column {{ index + 1 }}</label>
              <input 
                type="text" 
                class="form-input" 
                v-model="columnThemes[index]"
                :placeholder="'e.g., ' + columnPlaceholders[index]"
              >
            </div>
          </div>
          <div style="margin-top: 15px;">
            <button class="admin-btn secondary small-btn" @click="addColumn" :disabled="columnThemes.length >= 8">
              + Add Column
            </button>
            <button class="admin-btn secondary small-btn" @click="removeColumn" :disabled="columnThemes.length <= 3">
              - Remove Column
            </button>
          </div>
          <div class="theme-suggestions" style="margin-top: 15px;">
            <span class="form-label" style="width: 100%; margin-bottom: 8px;">Quick fill suggestions:</span>
            <span class="theme-chip" @click="fillColumnPreset('classic')">Classic Mix</span>
            <span class="theme-chip" @click="fillColumnPreset('science')">Science Focus</span>
            <span class="theme-chip" @click="fillColumnPreset('entertainment')">Entertainment</span>
            <span class="theme-chip" @click="fillColumnPreset('history')">History Focus</span>
            <span class="theme-chip" @click="fillColumnPreset('random')">Random Mix</span>
          </div>
        </div>

        <button 
          class="admin-btn ai" 
          @click="generateBoard" 
          :disabled="!apiKey || !canGenerate || isGenerating"
          style="margin-top: 20px;"
        >
          <span v-if="isGenerating" class="loading-spinner"></span>
          {{ isGenerating ? 'Generating Board...' : 'Generate Full Board' }}
        </button>
        
        <button 
          class="admin-btn secondary" 
          @click="generateSingleCategory" 
          :disabled="!apiKey || isGenerating"
          style="margin-top: 10px;"
          v-if="generationMode === 'themes' && aiTheme"
        >
          Generate Single Category
        </button>
      </div>

      <!-- Player Management -->
      <div class="admin-section">
        <h2 class="admin-title">Player Management</h2>
        <div class="player-management">
          <div v-for="(player, index) in players" :key="index" class="player-input-group">
            <input type="text" class="form-input" v-model="player.name" placeholder="Player Name">
            <input type="number" class="form-input" v-model.number="player.score" style="width: 100px;">
            <button class="admin-btn danger small-btn" @click="removePlayer(index)" v-if="players.length > 1">√ó</button>
          </div>
        </div>
        <button class="admin-btn secondary" @click="addPlayer">+ Add Player</button>
        <button class="admin-btn danger" @click="resetScores">Reset All Scores</button>
      </div>

      <!-- Board Configuration -->
      <div class="admin-section">
        <h2 class="admin-title">Board Configuration</h2>
        
        <div class="form-group">
          <label class="form-label">Point Values (comma-separated)</label>
          <input 
            type="text" 
            class="form-input" 
            v-model="pointValuesInput"
            @change="updatePointValues"
            placeholder="200, 400, 600, 800, 1000"
          >
        </div>

        <button class="admin-btn secondary" @click="addCategory">+ Add Category</button>
        <button class="admin-btn danger" @click="resetBoard">Reset Entire Board</button>
        <button class="admin-btn primary" @click="randomizeDailyDoubles">Randomize Daily Doubles</button>
      </div>

      <!-- Category Editor -->
      <div class="admin-section">
        <h2 class="admin-title">Categories & Questions</h2>
        <div class="category-grid">
          <div v-for="(category, catIndex) in categories" :key="catIndex" class="category-card">
            <div class="category-card-header">
              <input 
                type="text" 
                class="form-input" 
                v-model="category.name" 
                placeholder="Category Name"
                style="flex: 1; margin-right: 10px;"
              >
              <button class="admin-btn danger small-btn" @click="removeCategory(catIndex)" v-if="categories.length > 1">√ó</button>
            </div>
            <ul class="question-list">
              <li 
                v-for="(question, qIndex) in category.questions" 
                :key="qIndex"
                class="question-item"
                @click="editQuestion(catIndex, qIndex)"
              >
                <span class="question-item-value">${{ pointValues[qIndex] || (qIndex + 1) * 200 }}</span>
                <span 
                  class="question-item-status"
                  :class="{
                    'daily-double': question.isDailyDouble,
                    'has-content': question.question && question.answer,
                    'empty': !question.question || !question.answer
                  }"
                >
                  {{ question.isDailyDouble ? 'DD' : (question.question && question.answer ? '‚úì' : 'Empty') }}
                </span>
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Final Jeopardy Admin -->
      <div class="admin-section">
        <h2 class="admin-title" style="color: #9333ea; border-color: #9333ea;">Final Jeopardy</h2>
        <div class="final-jeopardy-admin-card">
          <div class="form-group">
            <label class="form-label">Category</label>
            <input 
              type="text" 
              class="form-input" 
              v-model="finalJeopardy.category"
              placeholder="Category name"
            >
          </div>

          <div class="form-group">
            <label class="form-label">Question / Clue</label>
            <textarea 
              class="form-textarea" 
              v-model="finalJeopardy.question"
              placeholder="Enter the Final Jeopardy clue"
            ></textarea>
          </div>

          <div class="form-group">
            <label class="form-label">Answer</label>
            <input 
              type="text" 
              class="form-input" 
              v-model="finalJeopardy.answer"
              placeholder="What is..."
            >
          </div>

          <div class="checkbox-group">
            <input type="checkbox" id="fjCompleted" v-model="finalJeopardy.revealed">
            <label for="fjCompleted">Mark as Completed</label>
          </div>

          <button class="admin-btn ai" @click="generateFinalJeopardy" :disabled="!apiKey || isGenerating" style="margin-top: 15px; background: linear-gradient(135deg, #9333ea, #6b21a8);">
            <span v-if="isGenerating" class="loading-spinner"></span>
            ü§ñ Generate with AI
          </button>
        </div>
      </div>

      <!-- Import/Export -->
      <div class="admin-section">
        <h2 class="admin-title">Import / Export</h2>
        <button class="admin-btn primary" @click="exportBoard">Export Board (JSON)</button>
        <button class="admin-btn secondary" @click="triggerImport">Import Board</button>
        <input type="file" ref="importInput" style="display: none;" accept=".json" @change="importBoard">
      </div>
    </div>

    <!-- Question Modal -->
    <div v-if="showQuestion" class="modal-overlay" @click.self="closeQuestion">
      <div class="question-card" :style="currentQuestion?.isFinalJeopardy ? 'border-color: #9333ea; box-shadow: 0 0 100px rgba(147,51,234,0.8), 0 0 50px rgba(212,175,55,0.3);' : ''">
        <div class="question-value" :style="currentQuestion?.isFinalJeopardy ? 'color: #9333ea;' : ''">
          {{ currentQuestion?.isFinalJeopardy ? 'FINAL JEOPARDY' : '$' + currentQuestion.value }}
        </div>
        <div class="question-text">{{ currentQuestion.question }}</div>
        <div v-if="showAnswer" class="answer-text">
          {{ currentQuestion.answer }}
        </div>
        <div class="modal-buttons">
          <button v-if="!showAnswer" class="modal-btn reveal" @click="showAnswer = true" :style="currentQuestion?.isFinalJeopardy ? 'background: linear-gradient(135deg, #9333ea, #6b21a8);' : ''">
            Reveal Answer
          </button>
          <button class="modal-btn close" @click="closeQuestion">
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- Daily Double Animation -->
    <div v-if="showDailyDouble" class="daily-double-overlay" @click="closeDailyDouble">
      <div class="dd-stars">
        <span v-for="n in 20" :key="n" class="dd-star" :style="starStyle(n)">‚òÖ</span>
      </div>
      <div class="daily-double-content">
        <div class="daily-double-text">DAILY</div>
        <div class="daily-double-text">DOUBLE!</div>
        <div class="daily-double-subtitle">Click anywhere to continue</div>
      </div>
    </div>

    <!-- Edit Question Modal -->
    <div v-if="editingQuestion" class="modal-overlay" @click.self="cancelEdit">
      <div class="edit-modal">
        <h2 class="edit-modal-title">Edit Question - ${{ pointValues[editingQuestion.qIndex] }}</h2>
        
        <div class="form-group">
          <label class="form-label">Question / Clue</label>
          <textarea 
            class="form-textarea" 
            v-model="editingQuestion.data.question"
            placeholder="Enter the clue (remember, answers should be in question form!)"
          ></textarea>
        </div>

        <div class="form-group">
          <label class="form-label">Answer</label>
          <input 
            type="text" 
            class="form-input" 
            v-model="editingQuestion.data.answer"
            placeholder="What is..."
          >
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="dailyDouble" v-model="editingQuestion.data.isDailyDouble">
          <label for="dailyDouble">Daily Double</label>
        </div>

        <div style="margin-top: 25px;">
          <button class="admin-btn primary" @click="saveQuestion">Save</button>
          <button class="admin-btn secondary" @click="cancelEdit">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Edit Final Jeopardy Modal -->
    <div v-if="editingFinalJeopardy" class="modal-overlay" @click.self="editingFinalJeopardy = false">
      <div class="edit-modal">
        <h2 class="edit-modal-title" style="color: #9333ea;">Edit Final Jeopardy</h2>
        
        <div class="form-group">
          <label class="form-label">Category</label>
          <input 
            type="text" 
            class="form-input" 
            v-model="finalJeopardy.category"
            placeholder="Category name"
          >
        </div>

        <div class="form-group">
          <label class="form-label">Question / Clue</label>
          <textarea 
            class="form-textarea" 
            v-model="finalJeopardy.question"
            placeholder="Enter the Final Jeopardy clue"
          ></textarea>
        </div>

        <div class="form-group">
          <label class="form-label">Answer</label>
          <input 
            type="text" 
            class="form-input" 
            v-model="finalJeopardy.answer"
            placeholder="What is..."
          >
        </div>

        <div style="margin-top: 25px;">
          <button class="admin-btn primary" @click="saveFinalJeopardy">Save</button>
          <button class="admin-btn secondary" @click="editingFinalJeopardy = false">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Final Jeopardy Wagers Modal -->
    <div v-if="showFinalJeopardyWagers" class="modal-overlay" @click.self="showFinalJeopardyWagers = false">
      <div class="edit-modal" style="border-color: #9333ea;">
        <h2 class="edit-modal-title" style="color: #9333ea;">Final Jeopardy Wagers</h2>
        <p style="color: #888; font-family: 'Roboto Condensed', sans-serif; margin-bottom: 20px;">
          Category: <strong style="color: white;">{{ finalJeopardy.category }}</strong>
        </p>
        
        <div v-for="(player, index) in players" :key="'wager-' + index" class="form-group">
          <label class="form-label">{{ player.name }} (Max: ${{ Math.max(0, player.score) }})</label>
          <input 
            type="number" 
            class="form-input" 
            v-model.number="playerWagers[index]"
            :max="Math.max(0, player.score)"
            min="0"
            placeholder="Enter wager"
          >
        </div>

        <div style="margin-top: 25px;">
          <button class="admin-btn primary" @click="startFinalJeopardy" style="background: linear-gradient(135deg, #9333ea, #6b21a8);">
            Reveal Question
          </button>
          <button class="admin-btn secondary" @click="showFinalJeopardyWagers = false">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container">
      <div v-for="(toast, index) in toasts" :key="index" class="toast" :class="toast.type">
        {{ toast.message }}
      </div>
    </div>

    <!-- Wrong Answer Animation -->
    <div v-if="showWrongAnswer" class="wrong-answer-overlay" @click="showWrongAnswer = false">
      <div class="wrong-answer-content">
        <div class="wrong-x">‚úó</div>
        <div class="wrong-text">WRONG!</div>
        <div class="wrong-amount">-${{ wrongAnswerAmount.toLocaleString() }}</div>
        <div class="wrong-player">{{ wrongAnswerPlayer }}</div>
      </div>
      <div class="wrong-sparks">
        <div v-for="i in 20" :key="'spark-' + i" class="spark" :style="sparkStyle(i)"></div>
      </div>
    </div>

    <!-- Correct Answer Animation -->
    <div v-if="showCorrectAnswer" class="correct-answer-overlay" @click="showCorrectAnswer = false">
      <div class="correct-answer-content">
        <div class="correct-check">‚úì</div>
        <div class="correct-text">CORRECT!</div>
        <div class="correct-amount">+${{ correctAnswerAmount.toLocaleString() }}</div>
        <div class="correct-player">{{ correctAnswerPlayer }}</div>
      </div>
      <div class="correct-stars">
        <div v-for="i in 30" :key="'cstar-' + i" class="correct-star" :style="correctStarStyle(i)">‚òÖ</div>
      </div>
      <div class="correct-rays">
        <div v-for="i in 12" :key="'ray-' + i" class="ray" :style="{ transform: 'rotate(' + (i * 30) + 'deg)' }"></div>
      </div>
    </div>

    <!-- Game Over Celebration -->
    <div v-if="showGameOver" class="game-over-overlay" @click.self="showGameOver = false">
      <!-- Spotlights -->
      <div class="spotlight"></div>
      <div class="spotlight"></div>
      <div class="spotlight"></div>
      
      <!-- Confetti -->
      <div class="confetti-container">
        <div 
          v-for="i in confettiPieces" 
          :key="i.id"
          class="confetti"
          :class="i.shape"
          :style="i.style"
        ></div>
      </div>

      <div class="game-over-content">
        <div class="trophy">üèÜ</div>
        <div class="game-over-title">GAME OVER!</div>
        
        <div v-if="winner" class="winner-announcement">
          <div>And the winner is...</div>
          <div class="winner-name">{{ winner.name }}</div>
          <div class="winner-score" :class="{ negative: winner.score < 0 }">
            {{ winner.score < 0 ? '-' : '' }}${{ Math.abs(winner.score).toLocaleString() }}
          </div>
        </div>

        <div v-if="isTie" class="winner-announcement">
          <div style="color: var(--jeopardy-gold); font-size: 48px;">IT'S A TIE!</div>
        </div>

        <div class="final-scores">
          <div 
            v-for="(player, index) in rankedPlayers" 
            :key="index"
            class="final-score-card"
            :class="{
              winner: index === 0 && !isTie,
              second: index === 1,
              third: index === 2
            }"
          >
            <div class="final-rank">{{ getRankLabel(index) }}</div>
            <div class="final-player-name">{{ player.name }}</div>
            <div class="final-player-score" :class="{ negative: player.score < 0 }">
              {{ player.score < 0 ? '-' : '' }}${{ Math.abs(player.score).toLocaleString() }}
            </div>
          </div>
        </div>

        <div>
          <button class="play-again-btn" @click="playAgain">Play Again</button>
          <button class="close-celebration-btn" @click="showGameOver = false">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          currentView: 'game',
          apiKey: localStorage.getItem('jeopardy_anthropic_key') || '',
          aiTheme: '',
          isGenerating: false,
          generationMode: 'themes', // 'themes' or 'columns'
          columnThemes: ['', '', '', '', '', ''],
          columnPlaceholders: ['Movies', 'Science', 'History', 'Sports', 'Music', 'Geography'],
          pointValues: [200, 400, 600, 800, 1000],
          pointValuesInput: '200, 400, 600, 800, 1000',
          currentQuestionValue: 200,
          categories: this.getDefaultCategories(),
          players: [
            { name: 'Player 1', score: 0 },
            { name: 'Player 2', score: 0 },
            { name: 'Player 3', score: 0 }
          ],
          activePlayer: 0,
          revealedCells: new Set(),
          showQuestion: false,
          showAnswer: false,
          showDailyDouble: false,
          currentQuestion: null,
          pendingQuestion: null,
          editingQuestion: null,
          toasts: [],
          showGameOver: false,
          confettiPieces: [],
          contextMenu: {
            show: false,
            x: 0,
            y: 0,
            catIndex: 0,
            valueIndex: 0
          },
          isFullscreen: false,
          finalJeopardy: {
            category: 'MYSTERY CATEGORY',
            question: '',
            answer: '',
            revealed: false
          },
          finalJeopardyContext: {
            show: false,
            x: 0,
            y: 0
          },
          playerWagers: {},
          showFinalJeopardyModal: false,
          showFinalJeopardyWagers: false,
          editingFinalJeopardy: false,
          showWrongAnswer: false,
          wrongAnswerAmount: 0,
          wrongAnswerPlayer: '',
          showCorrectAnswer: false,
          correctAnswerAmount: 0,
          correctAnswerPlayer: ''
        };
      },

      computed: {
        parsedThemes() {
          if (!this.aiTheme) return [];
          return this.aiTheme.split(',').map(t => t.trim()).filter(t => t.length > 0);
        },
        canGenerate() {
          if (this.generationMode === 'themes') {
            return this.aiTheme && this.aiTheme.trim().length > 0;
          } else {
            return this.columnThemes.some(t => t && t.trim().length > 0);
          }
        },
        totalQuestions() {
          return this.categories.length * this.pointValues.length;
        },
        progressPercent() {
          return (this.revealedCells.size / this.totalQuestions) * 100;
        },
        isGameComplete() {
          return this.revealedCells.size >= this.totalQuestions;
        },
        rankedPlayers() {
          return [...this.players].sort((a, b) => b.score - a.score);
        },
        winner() {
          if (this.players.length === 0) return null;
          const sorted = this.rankedPlayers;
          return sorted[0];
        },
        isTie() {
          if (this.players.length < 2) return false;
          const sorted = this.rankedPlayers;
          return sorted[0].score === sorted[1].score;
        }
      },

      methods: {
        addTheme(theme) {
          if (this.aiTheme) {
            // Check if theme already exists
            const existing = this.parsedThemes.map(t => t.toLowerCase());
            if (!existing.includes(theme.toLowerCase())) {
              this.aiTheme += ', ' + theme;
            }
          } else {
            this.aiTheme = theme;
          }
        },

        removeTheme(index) {
          const themes = this.parsedThemes;
          themes.splice(index, 1);
          this.aiTheme = themes.join(', ');
        },

        addColumn() {
          if (this.columnThemes.length < 8) {
            this.columnThemes.push('');
          }
        },

        removeColumn() {
          if (this.columnThemes.length > 3) {
            this.columnThemes.pop();
          }
        },

        fillColumnPreset(preset) {
          const presets = {
            classic: ['Science', 'History', 'Geography', 'Pop Culture', 'Sports', 'Literature'],
            science: ['Biology', 'Chemistry', 'Physics', 'Space', 'Technology', 'Medicine'],
            entertainment: ['Movies', 'TV Shows', 'Music', 'Video Games', 'Celebrities', 'Broadway'],
            history: ['Ancient History', 'World Wars', 'American History', 'Medieval Times', 'Famous Leaders', 'Historical Events'],
            random: ['Food & Drink', 'Animals', 'Art', 'Languages', 'Inventions', 'Mythology']
          };
          const selected = presets[preset] || presets.classic;
          this.columnThemes = [...selected];
        },

        async generateSingleCategory() {
          if (!this.apiKey || !this.aiTheme) return;

          this.isGenerating = true;
          const theme = this.parsedThemes[Math.floor(Math.random() * this.parsedThemes.length)] || this.aiTheme;

          const prompt = `Generate a single Jeopardy category with the theme: "${theme}"

Create 1 category with 5 questions. Questions should increase in difficulty from $200 to $1000.

IMPORTANT: Format the response as valid JSON only, with no markdown or extra text:
{
  "name": "CATEGORY NAME IN CAPS",
  "questions": [
    {"question": "Clue for $200", "answer": "What is [answer]?"},
    {"question": "Clue for $400", "answer": "What is [answer]?"},
    {"question": "Clue for $600", "answer": "What is [answer]?"},
    {"question": "Clue for $800", "answer": "What is [answer]?"},
    {"question": "Clue for $1000", "answer": "What is [answer]?"}
  ]
}

Make clues interesting and factually accurate. Answers must be phrased as questions.`;

          try {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'x-api-key': this.apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
              },
              body: JSON.stringify({
                model: 'claude-sonnet-4-20250514',
                max_tokens: 1000,
                messages: [
                  { role: 'user', content: prompt }
                ],
                system: 'You are a Jeopardy game writer. Always respond with valid JSON only, no markdown formatting.'
              })
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error?.message || 'API request failed');
            }

            const data = await response.json();
            let content = data.content[0].text;
            content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
            
            const category = JSON.parse(content);

            this.categories.push({
              name: category.name,
              questions: category.questions.map(q => ({
                question: q.question,
                answer: q.answer,
                isDailyDouble: false
              }))
            });

            this.showToast(`Added category: ${category.name}`, 'success');
          } catch (error) {
            console.error('Generation error:', error);
            this.showToast(`Error: ${error.message}`, 'error');
          }

          this.isGenerating = false;
        },

        getDefaultCategories() {
          const defaultCats = [
            'SCIENCE', 'HISTORY', 'GEOGRAPHY', 'POP CULTURE', 'SPORTS', 'LITERATURE'
          ];
          return defaultCats.map(name => ({
            name,
            questions: Array(5).fill(null).map(() => ({
              question: '',
              answer: '',
              isDailyDouble: false
            }))
          }));
        },

        isRevealed(catIndex, valueIndex) {
          return this.revealedCells.has(`${catIndex}-${valueIndex}`);
        },

        selectQuestion(catIndex, valueIndex) {
          if (this.isRevealed(catIndex, valueIndex)) return;

          const question = this.categories[catIndex].questions[valueIndex];
          const value = this.pointValues[valueIndex];

          if (!question.question) {
            this.showToast('No question set for this cell!', 'error');
            return;
          }

          this.currentQuestion = {
            ...question,
            value,
            catIndex,
            valueIndex
          };
          this.currentQuestionValue = value;

          if (question.isDailyDouble) {
            this.pendingQuestion = this.currentQuestion;
            this.showDailyDouble = true;
            // Play sound effect (browser audio)
            this.playDailyDoubleSound();
          } else {
            this.showQuestion = true;
            this.showAnswer = false;
          }

          this.revealedCells.add(`${catIndex}-${valueIndex}`);
        },

        playDailyDoubleSound() {
          // Create an oscillator for a simple sound effect
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
            osc.frequency.setValueAtTime(659.25, ctx.currentTime + 0.1); // E5
            osc.frequency.setValueAtTime(783.99, ctx.currentTime + 0.2); // G5
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.5);
          } catch (e) {
            // Audio not supported
          }
        },

        closeDailyDouble() {
          this.showDailyDouble = false;
          if (this.pendingQuestion) {
            this.currentQuestion = this.pendingQuestion;
            this.showQuestion = true;
            this.showAnswer = false;
            this.pendingQuestion = null;
          }
        },

        closeQuestion() {
          if (this.currentQuestion?.isFinalJeopardy) {
            this.finalJeopardy.revealed = true;
          }
          this.showQuestion = false;
          this.showAnswer = false;
          this.currentQuestion = null;
        },

        starStyle(n) {
          return {
            left: `${Math.random() * 100}%`,
            top: `${Math.random() * 100}%`,
            animationDelay: `${Math.random() * 2}s`,
            fontSize: `${20 + Math.random() * 30}px`
          };
        },

        adjustScore(amount) {
          if (this.activePlayer === null) return;
          this.players[this.activePlayer].score += amount;
          
          if (amount < 0) {
            this.triggerWrongAnswer(Math.abs(amount), this.players[this.activePlayer].name);
          } else {
            this.triggerCorrectAnswer(amount, this.players[this.activePlayer].name);
          }
        },

        addPlayer() {
          this.players.push({ name: `Player ${this.players.length + 1}`, score: 0 });
        },

        removePlayer(index) {
          this.players.splice(index, 1);
          if (this.activePlayer >= this.players.length) {
            this.activePlayer = this.players.length - 1;
          }
        },

        resetScores() {
          this.players.forEach(p => p.score = 0);
          this.showToast('All scores reset!', 'success');
        },

        addCategory() {
          this.categories.push({
            name: 'NEW CATEGORY',
            questions: Array(this.pointValues.length).fill(null).map(() => ({
              question: '',
              answer: '',
              isDailyDouble: false
            }))
          });
        },

        removeCategory(index) {
          this.categories.splice(index, 1);
        },

        updatePointValues() {
          const values = this.pointValuesInput.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
          if (values.length > 0) {
            this.pointValues = values;
            // Adjust questions array for each category
            this.categories.forEach(cat => {
              while (cat.questions.length < values.length) {
                cat.questions.push({ question: '', answer: '', isDailyDouble: false });
              }
              while (cat.questions.length > values.length) {
                cat.questions.pop();
              }
            });
          }
        },

        randomizeDailyDoubles() {
          // Clear existing daily doubles
          this.categories.forEach(cat => {
            cat.questions.forEach(q => q.isDailyDouble = false);
          });

          // Set 2 random daily doubles
          const positions = [];
          while (positions.length < 2) {
            const catIndex = Math.floor(Math.random() * this.categories.length);
            const qIndex = Math.floor(Math.random() * this.pointValues.length);
            const key = `${catIndex}-${qIndex}`;
            if (!positions.includes(key)) {
              positions.push(key);
              this.categories[catIndex].questions[qIndex].isDailyDouble = true;
            }
          }
          this.showToast('Daily Doubles randomized!', 'success');
        },

        resetBoard() {
          this.categories = this.getDefaultCategories();
          this.revealedCells = new Set();
          this.showToast('Board reset!', 'success');
        },

        editQuestion(catIndex, qIndex) {
          this.editingQuestion = {
            catIndex,
            qIndex,
            data: { ...this.categories[catIndex].questions[qIndex] }
          };
        },

        saveQuestion() {
          const { catIndex, qIndex, data } = this.editingQuestion;
          this.categories[catIndex].questions[qIndex] = { ...data };
          this.editingQuestion = null;
          this.showToast('Question saved!', 'success');
        },

        cancelEdit() {
          this.editingQuestion = null;
        },

        saveApiKey() {
          localStorage.setItem('jeopardy_anthropic_key', this.apiKey);
          this.showToast('API key saved!', 'success');
        },

        async generateBoard() {
          if (!this.apiKey || !this.canGenerate) return;

          this.isGenerating = true;

          let prompt;
          let numCategories;

          if (this.generationMode === 'columns') {
            // Column-based generation
            const filledColumns = this.columnThemes.filter(t => t && t.trim().length > 0);
            numCategories = filledColumns.length;
            
            const columnInstructions = filledColumns.map((theme, i) => 
              `Category ${i + 1}: "${theme}"`
            ).join('\n');

            prompt = `Generate a complete Jeopardy game board with these specific category themes:

${columnInstructions}

Create exactly ${numCategories} categories with 5 questions each. Questions should increase in difficulty from $200 to $1000.

IMPORTANT: Format the response as valid JSON only, with no markdown or extra text. Use this exact structure:
{
  "categories": [
    {
      "name": "CATEGORY NAME IN CAPS",
      "questions": [
        {"question": "Clue text here", "answer": "What is [answer]?"},
        {"question": "Clue text here", "answer": "What is [answer]?"},
        {"question": "Clue text here", "answer": "What is [answer]?"},
        {"question": "Clue text here", "answer": "What is [answer]?"},
        {"question": "Clue text here", "answer": "What is [answer]?"}
      ]
    }
  ]
}

The category names should be creative variations of the themes provided (not just the exact theme text).
Make the clues interesting, varied, and factually accurate.
Ensure all answers are phrased as questions (What is..., Who is..., etc.)`;

          } else {
            // Theme-based generation
            const themes = this.parsedThemes;
            numCategories = 6;
            
            let themeInstruction;
            if (themes.length === 1) {
              themeInstruction = `Create 6 different categories all related to the theme: "${themes[0]}"`;
            } else {
              themeInstruction = `Create 6 categories covering these themes: ${themes.join(', ')}. 
You can create multiple categories per theme if there are fewer than 6 themes, or pick the most interesting ones if there are more than 6.`;
            }

            prompt = `Generate a complete Jeopardy game board.

${themeInstruction}

Create exactly 6 categories with 5 questions each. Questions should increase in difficulty from $200 to $1000.

IMPORTANT: Format the response as valid JSON only, with no markdown or extra text. Use this exact structure:
{
  "categories": [
    {
      "name": "CATEGORY NAME IN CAPS",
      "questions": [
        {"question": "Clue text here", "answer": "What is [answer]?"},
        {"question": "Clue text here", "answer": "What is [answer]?"},
        {"question": "Clue text here", "answer": "What is [answer]?"},
        {"question": "Clue text here", "answer": "What is [answer]?"},
        {"question": "Clue text here", "answer": "What is [answer]?"}
      ]
    }
  ]
}

Make the clues interesting, varied, and factually accurate. Include a mix of:
- Direct knowledge questions
- Fill-in-the-blank style clues  
- "This person/place/thing" style clues
- Wordplay and puns where appropriate

Ensure all answers are phrased as questions (What is..., Who is..., What are..., etc.)`;
          }

          try {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'x-api-key': this.apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
              },
              body: JSON.stringify({
                model: 'claude-sonnet-4-20250514',
                max_tokens: 4000,
                messages: [
                  { role: 'user', content: prompt }
                ],
                system: 'You are a Jeopardy game writer. Generate creative, accurate, and entertaining trivia questions. Always respond with valid JSON only, no markdown formatting.'
              })
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error?.message || 'API request failed');
            }

            const data = await response.json();
            let content = data.content[0].text;
            
            // Clean up potential markdown formatting
            content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
            
            const board = JSON.parse(content);

            if (board.categories && board.categories.length >= 1) {
              this.categories = board.categories.map(cat => ({
                name: cat.name,
                questions: cat.questions.map(q => ({
                  question: q.question,
                  answer: q.answer,
                  isDailyDouble: false
                }))
              }));
              
              // Add random daily doubles
              this.randomizeDailyDoubles();
              
              // Reset revealed cells
              this.revealedCells = new Set();
              
              this.showToast('Board generated successfully!', 'success');
            } else {
              throw new Error('Invalid response structure');
            }
          } catch (error) {
            console.error('Generation error:', error);
            this.showToast(`Error: ${error.message}`, 'error');
          }

          this.isGenerating = false;
        },

        exportBoard() {
          const data = {
            categories: this.categories,
            pointValues: this.pointValues,
            players: this.players
          };
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'jeopardy-board.json';
          a.click();
          URL.revokeObjectURL(url);
          this.showToast('Board exported!', 'success');
        },

        triggerImport() {
          this.$refs.importInput.click();
        },

        importBoard(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (data.categories) {
                this.categories = data.categories;
              }
              if (data.pointValues) {
                this.pointValues = data.pointValues;
                this.pointValuesInput = data.pointValues.join(', ');
              }
              if (data.players) {
                this.players = data.players;
              }
              this.revealedCells = new Set();
              this.showToast('Board imported!', 'success');
            } catch (error) {
              this.showToast('Invalid file format', 'error');
            }
          };
          reader.readAsText(file);
          event.target.value = '';
        },

        showToast(message, type = 'success') {
          this.toasts.push({ message, type });
          setTimeout(() => {
            this.toasts.shift();
          }, 3000);
        },

        finishGame() {
          this.generateConfetti();
          this.showGameOver = true;
          this.playVictorySound();
        },

        generateConfetti() {
          const colors = ['#d4af37', '#ffd700', '#ff6b6b', '#4ade80', '#60a5fa', '#f472b6', '#a78bfa', '#ffffff'];
          const shapes = ['square', 'circle', 'triangle'];
          this.confettiPieces = [];
          
          for (let i = 0; i < 150; i++) {
            this.confettiPieces.push({
              id: i,
              shape: shapes[Math.floor(Math.random() * shapes.length)],
              style: {
                left: Math.random() * 100 + '%',
                backgroundColor: colors[Math.floor(Math.random() * colors.length)],
                width: (Math.random() * 10 + 5) + 'px',
                height: (Math.random() * 10 + 5) + 'px',
                animationDuration: (Math.random() * 3 + 2) + 's',
                animationDelay: (Math.random() * 2) + 's'
              }
            });
          }
        },

        playVictorySound() {
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
            
            notes.forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
              gain.gain.setValueAtTime(0.2, ctx.currentTime + i * 0.15);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.5);
              osc.start(ctx.currentTime + i * 0.15);
              osc.stop(ctx.currentTime + i * 0.15 + 0.5);
            });
          } catch (e) {
            // Audio not supported
          }
        },

        getRankLabel(index) {
          const labels = ['ü•á 1st', 'ü•à 2nd', 'ü•â 3rd', '4th', '5th', '6th', '7th', '8th'];
          return labels[index] || `${index + 1}th`;
        },

        playAgain() {
          this.revealedCells = new Set();
          this.players.forEach(p => p.score = 0);
          this.finalJeopardy.revealed = false;
          this.playerWagers = {};
          this.initializeWagers();
          this.showGameOver = false;
          this.randomizeDailyDoubles();
          this.showToast('New game started!', 'success');
        },

        // Context Menu Methods
        openContextMenu(event, catIndex, valueIndex) {
          this.contextMenu = {
            show: true,
            x: event.clientX,
            y: event.clientY,
            catIndex,
            valueIndex
          };
        },

        closeContextMenu() {
          this.contextMenu.show = false;
          this.finalJeopardyContext.show = false;
        },

        isDailyDouble(catIndex, valueIndex) {
          return this.categories[catIndex]?.questions[valueIndex]?.isDailyDouble || false;
        },

        editFromContextMenu() {
          const { catIndex, valueIndex } = this.contextMenu;
          this.editQuestion(catIndex, valueIndex);
          this.closeContextMenu();
        },

        toggleDailyDoubleFromContext() {
          const { catIndex, valueIndex } = this.contextMenu;
          const question = this.categories[catIndex].questions[valueIndex];
          question.isDailyDouble = !question.isDailyDouble;
          this.showToast(question.isDailyDouble ? 'Daily Double set!' : 'Daily Double removed', 'success');
          this.closeContextMenu();
        },

        toggleRevealedFromContext() {
          const { catIndex, valueIndex } = this.contextMenu;
          const key = `${catIndex}-${valueIndex}`;
          if (this.revealedCells.has(key)) {
            this.revealedCells.delete(key);
            // Force reactivity
            this.revealedCells = new Set(this.revealedCells);
            this.showToast('Cell marked unrevealed', 'success');
          } else {
            this.revealedCells.add(key);
            this.revealedCells = new Set(this.revealedCells);
            this.showToast('Cell marked revealed', 'success');
          }
          this.closeContextMenu();
        },

        previewQuestion() {
          const { catIndex, valueIndex } = this.contextMenu;
          const question = this.categories[catIndex].questions[valueIndex];
          const value = this.pointValues[valueIndex];
          
          if (!question.question) {
            this.showToast('No question set for this cell', 'error');
            this.closeContextMenu();
            return;
          }

          this.currentQuestion = {
            ...question,
            value,
            catIndex,
            valueIndex
          };
          this.showQuestion = true;
          this.showAnswer = false;
          this.closeContextMenu();
        },

        clearQuestion() {
          const { catIndex, valueIndex } = this.contextMenu;
          this.categories[catIndex].questions[valueIndex] = {
            question: '',
            answer: '',
            isDailyDouble: false
          };
          this.showToast('Question cleared', 'success');
          this.closeContextMenu();
        },

        awardPointsFromContext(playerIndex, isCorrect) {
          const { catIndex, valueIndex } = this.contextMenu;
          const value = this.pointValues[valueIndex];
          const amount = isCorrect ? value : -value;
          
          this.players[playerIndex].score += amount;
          
          // Mark cell as revealed
          const key = `${catIndex}-${valueIndex}`;
          if (!this.revealedCells.has(key)) {
            this.revealedCells.add(key);
            this.revealedCells = new Set(this.revealedCells);
          }
          
          if (isCorrect) {
            // Show correct answer animation
            this.triggerCorrectAnswer(value, this.players[playerIndex].name);
          } else {
            // Show wrong answer animation
            this.triggerWrongAnswer(value, this.players[playerIndex].name);
          }
          
          this.closeContextMenu();
        },

        triggerCorrectAnswer(amount, playerName) {
          this.correctAnswerAmount = amount;
          this.correctAnswerPlayer = playerName;
          this.showCorrectAnswer = true;
          this.playCorrectSound();
          
          // Auto-close after 2 seconds
          setTimeout(() => {
            this.showCorrectAnswer = false;
          }, 2000);
        },

        playCorrectSound() {
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Triumphant ascending arpeggio
            const notes = [523.25, 659.25, 783.99, 1046.50, 1318.51]; // C5, E5, G5, C6, E6
            
            notes.forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              
              osc.type = 'sine';
              osc.connect(gain);
              gain.connect(ctx.destination);
              
              const startTime = ctx.currentTime + i * 0.08;
              osc.frequency.setValueAtTime(freq, startTime);
              gain.gain.setValueAtTime(0.25, startTime);
              gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);
              
              osc.start(startTime);
              osc.stop(startTime + 0.4);
            });
            
            // Add a nice shimmer
            const shimmer = ctx.createOscillator();
            const shimmerGain = ctx.createGain();
            shimmer.type = 'triangle';
            shimmer.frequency.setValueAtTime(2093, ctx.currentTime + 0.3); // C7
            shimmer.connect(shimmerGain);
            shimmerGain.connect(ctx.destination);
            shimmerGain.gain.setValueAtTime(0.15, ctx.currentTime + 0.3);
            shimmerGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.8);
            shimmer.start(ctx.currentTime + 0.3);
            shimmer.stop(ctx.currentTime + 0.8);
            
          } catch (e) {
            // Audio not supported
          }
        },

        correctStarStyle(i) {
          const angle = (i / 30) * Math.PI * 2 + Math.random() * 0.5;
          const distance = 150 + Math.random() * 350;
          const tx = Math.cos(angle) * distance;
          const ty = Math.sin(angle) * distance;
          
          return {
            left: '50%',
            top: '50%',
            '--tx': tx + 'px',
            '--ty': ty + 'px',
            animationDelay: (Math.random() * 0.5) + 's',
            fontSize: (20 + Math.random() * 30) + 'px'
          };
        },

        triggerWrongAnswer(amount, playerName) {
          this.wrongAnswerAmount = amount;
          this.wrongAnswerPlayer = playerName;
          this.showWrongAnswer = true;
          this.playWrongSound();
          
          // Auto-close after 2 seconds
          setTimeout(() => {
            this.showWrongAnswer = false;
          }, 2000);
        },

        playWrongSound() {
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Buzzer sound - descending harsh tones
            const oscillators = [];
            const frequencies = [400, 300, 200];
            
            frequencies.forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              
              osc.type = 'sawtooth';
              osc.connect(gain);
              gain.connect(ctx.destination);
              
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.1);
              gain.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.1);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.1 + 0.3);
              
              osc.start(ctx.currentTime + i * 0.1);
              osc.stop(ctx.currentTime + i * 0.1 + 0.3);
              oscillators.push(osc);
            });
            
            // Add a low rumble
            const rumble = ctx.createOscillator();
            const rumbleGain = ctx.createGain();
            rumble.type = 'sine';
            rumble.frequency.setValueAtTime(80, ctx.currentTime);
            rumble.connect(rumbleGain);
            rumbleGain.connect(ctx.destination);
            rumbleGain.gain.setValueAtTime(0.4, ctx.currentTime);
            rumbleGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            rumble.start(ctx.currentTime);
            rumble.stop(ctx.currentTime + 0.5);
            
          } catch (e) {
            // Audio not supported
          }
        },

        sparkStyle(i) {
          const angle = (i / 20) * Math.PI * 2;
          const distance = 200 + Math.random() * 300;
          const tx = Math.cos(angle) * distance;
          const ty = Math.sin(angle) * distance;
          
          return {
            left: '50%',
            top: '50%',
            '--tx': tx + 'px',
            '--ty': ty + 'px',
            animationDelay: (Math.random() * 0.3) + 's',
            width: (3 + Math.random() * 5) + 'px',
            height: (3 + Math.random() * 5) + 'px'
          };
        },

        toggleFullscreen() {
          this.isFullscreen = !this.isFullscreen;
          
          if (this.isFullscreen) {
            // Try native fullscreen API
            if (document.documentElement.requestFullscreen) {
              document.documentElement.requestFullscreen().catch(() => {});
            }
          } else {
            if (document.exitFullscreen && document.fullscreenElement) {
              document.exitFullscreen().catch(() => {});
            }
          }
        },

        handleFullscreenChange() {
          if (!document.fullscreenElement) {
            this.isFullscreen = false;
          }
        },

        // Final Jeopardy Methods
        showFinalJeopardy() {
          if (this.finalJeopardy.revealed) return;
          
          if (!this.finalJeopardy.question) {
            this.showToast('No Final Jeopardy question set! Right-click to edit.', 'error');
            return;
          }
          
          this.showFinalJeopardyWagers = true;
        },

        openFinalJeopardyContext(event) {
          this.finalJeopardyContext = {
            show: true,
            x: event.clientX,
            y: event.clientY
          };
          // Close other context menu
          this.contextMenu.show = false;
        },

        closeFinalJeopardyContext() {
          this.finalJeopardyContext.show = false;
        },

        editFinalJeopardy() {
          this.editingFinalJeopardy = true;
          this.closeFinalJeopardyContext();
        },

        saveFinalJeopardy() {
          this.editingFinalJeopardy = false;
          this.showToast('Final Jeopardy saved!', 'success');
        },

        toggleFinalJeopardyRevealed() {
          this.finalJeopardy.revealed = !this.finalJeopardy.revealed;
          this.showToast(this.finalJeopardy.revealed ? 'Final Jeopardy marked complete' : 'Final Jeopardy marked incomplete', 'success');
          this.closeFinalJeopardyContext();
        },

        awardFinalJeopardy(playerIndex, isCorrect) {
          const wager = this.playerWagers[playerIndex] || 0;
          const amount = isCorrect ? wager : -wager;
          
          this.players[playerIndex].score += amount;
          this.finalJeopardy.revealed = true;
          
          if (wager > 0) {
            if (isCorrect) {
              this.triggerCorrectAnswer(wager, this.players[playerIndex].name);
            } else {
              this.triggerWrongAnswer(wager, this.players[playerIndex].name);
            }
          } else {
            const action = isCorrect ? 'awarded' : 'deducted';
            this.showToast(`$${wager} ${action} ${isCorrect ? 'to' : 'from'} ${this.players[playerIndex].name}`, 'success');
          }
          
          this.closeFinalJeopardyContext();
        },

        startFinalJeopardy() {
          this.showFinalJeopardyWagers = false;
          this.currentQuestion = {
            question: this.finalJeopardy.question,
            answer: this.finalJeopardy.answer,
            value: 'FINAL',
            isFinalJeopardy: true
          };
          this.showQuestion = true;
          this.showAnswer = false;
        },

        initializeWagers() {
          this.players.forEach((player, index) => {
            if (!(index in this.playerWagers)) {
              this.playerWagers[index] = 0;
            }
          });
        },

        async generateFinalJeopardy() {
          if (!this.apiKey) return;

          this.isGenerating = true;

          const prompt = `Generate a Final Jeopardy question. Pick an interesting, challenging category.

IMPORTANT: Format the response as valid JSON only, with no markdown or extra text:
{
  "category": "CATEGORY NAME IN CAPS",
  "question": "A challenging clue that requires thought",
  "answer": "What is [answer]?"
}

Make it challenging but fair - something knowledgeable contestants could figure out with some thought.`;

          try {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'x-api-key': this.apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
              },
              body: JSON.stringify({
                model: 'claude-sonnet-4-20250514',
                max_tokens: 500,
                messages: [
                  { role: 'user', content: prompt }
                ],
                system: 'You are a Jeopardy game writer. Always respond with valid JSON only, no markdown formatting.'
              })
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error?.message || 'API request failed');
            }

            const data = await response.json();
            let content = data.content[0].text;
            content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
            
            const fj = JSON.parse(content);

            this.finalJeopardy.category = fj.category;
            this.finalJeopardy.question = fj.question;
            this.finalJeopardy.answer = fj.answer;
            this.finalJeopardy.revealed = false;

            this.showToast('Final Jeopardy generated!', 'success');
          } catch (error) {
            console.error('Generation error:', error);
            this.showToast(`Error: ${error.message}`, 'error');
          }

          this.isGenerating = false;
        }
      },

      mounted() {
        // Load saved board from localStorage if exists
        const saved = localStorage.getItem('jeopardy_board');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            if (data.categories) this.categories = data.categories;
            if (data.pointValues) {
              this.pointValues = data.pointValues;
              this.pointValuesInput = data.pointValues.join(', ');
            }
            if (data.players) this.players = data.players;
            if (data.finalJeopardy) this.finalJeopardy = data.finalJeopardy;
          } catch (e) {
            // Use defaults
          }
        }

        // Initialize wagers
        this.initializeWagers();

        // Auto-save on changes
        this.$watch(
          () => ({ categories: this.categories, pointValues: this.pointValues, players: this.players, finalJeopardy: this.finalJeopardy }),
          (newVal) => {
            localStorage.setItem('jeopardy_board', JSON.stringify(newVal));
          },
          { deep: true }
        );

        // Auto-trigger game over when all questions answered
        this.$watch(
          () => this.revealedCells.size,
          (newSize) => {
            if (newSize > 0 && newSize >= this.totalQuestions && !this.showGameOver) {
              setTimeout(() => {
                this.finishGame();
              }, 500);
            }
          }
        );

        // Close context menu on click outside
        document.addEventListener('click', this.closeContextMenu);
        document.addEventListener('scroll', this.closeContextMenu);
        
        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
      },

      beforeUnmount() {
        document.removeEventListener('click', this.closeContextMenu);
        document.removeEventListener('scroll', this.closeContextMenu);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
      }
    }).mount('#app');
  </script>
</body>
</html>
